## OpenCV绘图

[toc]

参考[OpenCV中文官方文档](http://www.woshicver.com/ThirdSection/2_4_%E9%BC%A0%E6%A0%87%E4%BD%9C%E4%B8%BA%E7%94%BB%E7%AC%94/)

### 前言

通过**cv.line()**，**cv.circle()**，**cv.rectangle()**，**cv.ellipse()**，**cv.putText**()绘制不同的几何形状

参数：

- img：您要绘制形状的图像
- color：形状的颜色。对于BGR，将其作为元组传递，例如：(255,0,0)对于蓝色。对于灰度，只需传递标量值即可。
- 厚度：线或圆等的粗细。如果对闭合图形（如圆）传递`-1` ，它将填充形状。*默认厚度= 1*
- lineType：线的类型，是否为8连接线，抗锯齿线等。*默认情况下*，为8连接线。**cv.LINE_AA**给出了抗锯齿的线条，看起来非常适合曲线。

### 直线`line()`

```c++
CV_EXPORTS_W void line(InputOutputArray img, Point pt1, Point pt2, const Scalar& color,
                     int thickness = 1, int lineType = LINE_8, int shift = 0);
```

- img：图像.
- pt1：线条起点.
- pt2：线条终点.
- color：线条颜色.
- thickness：线条宽度.
- lineType：线型

```c++
#include <QCoreApplication>
#include "opencv2/opencv.hpp"
using namespace cv;
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    Mat src = imread("./../../images/book.bmp");
    line(src,Point(511,0),Point(511,511),Scalar(255,0,0),5);
    imshow("line",src);
    waitKey(0);
    return 0;
}
```

<center>
    <img src = "https://gitee.com/tianzhendong/img/raw/master//images/image-20220221085438392.png" width = 50%>
    <br>
    插入直线
</center>


### 矩形`rectangle()`

要绘制矩形，您需要矩形的左上角和右下角。

```c++
//方法1，矩形的左上角和右下角
void rectangle(InputOutputArray img, Point pt1, Point pt2,
                          const Scalar& color, int thickness = 1,
                          int lineType = LINE_8, int shift = 0);
//方法2，矩形的位置和长宽
void rectangle(InputOutputArray img, Rect rec,
                          const Scalar& color, int thickness = 1,
                          int lineType = LINE_8, int shift = 0);
```

- img：图像。
- pt1、pt2：矩形的左上角和右下角
- rec：矩形的位置和长宽
- color：线条颜色 (RGB) 或亮度（灰度图像 ）(grayscale image）。
- thickness：组成矩形的线条的粗细程度。取负值时（如CV_FILLED）函数绘制填充了色彩的矩形。
- line_type：线条的类型。见cvLine的描述
- shift：坐标点的小数点位数。

```c++
#include <QCoreApplication>
#include "opencv2/opencv.hpp"
using namespace cv;
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    Mat src = imread("./../../images/book.bmp");
    rectangle(src,Rect(0, 0, 100, 100),Scalar(255,0,0),1);
    //rectangle(src,Point(0,0),Rect(100,100)，Scalar(255,0,0),1);
    imshow("rectangle",src);
    waitKey(0);
    return 0;
}
```

<center>
    <img src = "https://gitee.com/tianzhendong/img/raw/master//images/image-20220221090010962.png" width = 50%>
    <br>
    画矩形
</center>


### 圆圈、点`circle()`

画圆画点都是使用circle()函数来画，点就是圆，我们平常所说的圆只不过是半径大一点而已。

```c++
void circle(InputOutputArray img, Point center, int radius,
                       const Scalar& color, int thickness = 1,
                       int lineType = LINE_8, int shift = 0);
```

- img：图像。
- center：圆心坐标。
- radius：圆形的半径。
- color：线条的颜色。
- thickness：如果是正数，表示组成圆的线条的粗细程度。否则，表示圆是否被填充。
- line_type：线条的类型。见 cvLine 的描述
- shift：圆心坐标点和半径值的小数点位数。

```c++
#include <QCoreApplication>
#include "opencv2/opencv.hpp"
using namespace cv;
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    Mat src = imread("./../../images/book.bmp");
    //画空心圆圈
    circle(src,Point(100,100),50,Scalar(0,0,255),1);
    //画实心圆圈
    circle(src,Point(200,200),50,Scalar(0,0,255),-1);
    //画点
    circle(src,Point(100,100),1,Scalar(0,0,255),-1);
    imshow("circle",src);
    waitKey(0);
    return 0;
}
```

<center>
    <img src="https://gitee.com/tianzhendong/img/raw/master//images/20220221091936.png" width =50%>
    <br>
    画点和圆
</center>


### 画椭圆`ellipse()`

```c++
void ellipse(InputOutputArray img, const RotatedRect& box, const Scalar& color,
                        int thickness = 1, int lineType = LINE_8);

void ellipse(InputOutputArray img, Point center, Size axes,
                        double angle, double startAngle, double endAngle,
                        const Scalar& color, int thickness = 1,
                        int lineType = LINE_8, int shift = 0);
```

- img：图像。
- center：椭圆圆心坐标。
- axes：轴的长度(横轴，纵轴)。
- angle：偏转的角度。
- start_angle：圆弧起始角的角度。
- end_angle：圆弧终结角的角度。
- color：线条的颜色。
- thickness：线条的粗细程度。
- line_type：线条的类型,见CVLINE的描述。
- shift：圆心坐标点和数轴的精度。

```c++
#include <QCoreApplication>
#include "opencv2/opencv.hpp"
using namespace cv;
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    Mat src = imread("./../../images/book.bmp");
    //画椭圆
    ellipse(src,Point(100,100),Size(100,50),30,0,360,Scalar(0,0,255),1,8);

    imshow("circle",src);
    waitKey(0);
    return 0;
}
```

<center>
    <img src="https://gitee.com/tianzhendong/img/raw/master//images/20220221093515.png" width=50%>
    <br>
    画椭圆
</center>


### 多边形`polylines()`

```c++
void polylines(InputOutputArray img, InputArrayOfArrays pts,
                            bool isClosed, const Scalar& color,
                            int thickness = 1, int lineType = LINE_8, int shift = 0 );
```

### 添加文本`putText()`

```c++
void putText( InputOutputArray img, const String& text, Point org,
                         int fontFace, double fontScale, Scalar color,
                         int thickness = 1, int lineType = LINE_8,
                         bool bottomLeftOrigin = false );
```

- img：图像
- text：文本，string格式
- org：放置的点位置（数据开始的左下角）
- fontFace：字体类型
- fontScale：字体比例
- color：字体颜色
- thickness：字体粗细
- lineType：线形

```c++
#include <QCoreApplication>
#include "opencv2/opencv.hpp"
using namespace cv;
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    Mat src = imread("./../../images/book.bmp");
    //文本
    putText(src,"text",Point(100,100),FONT_HERSHEY_PLAIN,4,Scalar(255,0,0),2,LINE_AA);

    imshow("circle",src);
    waitKey(0);
    return 0;
}
```

<center>
    <img src="https://gitee.com/tianzhendong/img/raw/master//images/20220221094849.png" width=50%>
    <br>
    文本
</center>

## 绘制并填充

```python
#绘制一个填充的凸多边形。这个函数比fillPoly函数快得多。它不仅可以填充凸多边形，也可以填充任何无自交点的单调多边形，即轮廓与每条水平线(扫描线)最多交点两次的多边形(尽管它的顶边和/或底边可以是水平的)。
def fillConvexPoly(img, points, color, lineType=None, shift=None)
```

`fillConvexPoly(img, points, color, lineType=None, shift=None):`

#绘制一个填充的凸多边形。这个函数比fillPoly函数快得多。它不仅可以填充凸多边形，也可以填充任何无自交点的单调多边形，即轮廓与每条水平线(扫描线)最多交点两次的多边形(尽管它的顶边和/或底边可以是水平的)。

```python
def fillPoly(img, pts, color, lineType=None, shift=None, offset=None)
```

填充由几个多边形轮廓围成的区域。该函数可以填充复杂的区域，例如，带有孔洞的区域，带有自交点的轮廓(它们的某些部分，等等)。

- pts:多边形数组，其中每个多边形表示为一个点数组。

```python
def polylines(img, pts, isClosed, color, thickness=None, lineType=None, shift=None)
```

绘制多个多边形曲线。

