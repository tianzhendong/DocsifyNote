---
title: 网络编程
tags: Code
notebook: JAVA
---

[toc]
# 网络基础
## 网络编程的目的
直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯
## 网络编程中两个主要问题
* 如何准确地定位网络上一台或多台主机，定位主机上的特定应用
* 找到住后如何可靠高效地进行数据传输

## 网络层级

了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference [Model](https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020)）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。

　　除了标准的OSI七层模型以外，常见的[网络层](https://so.csdn.net/so/search?q=网络层&spm=1001.2101.3001.7020)次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：

![img](https://gitee.com/tianzhendong/img/raw/master//images/764050-20150904094019903-1923900106.jpg)

![img](https://gitee.com/tianzhendong/img/raw/master//images/764050-20150904095142060-1017190812.gif)

### 物理层

激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。**该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。**物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。

### 数据链路层

数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

　　有关数据链路层的重要知识点：

　　**1> 数据链路层为网络层提供可靠的数据传输；**

　　**2> 基本数据单位为帧；**

　　**3> 主要的协议：以太网协议；**

　　**4> 两个重要设备名称：网桥和交换机。**

### 网络层

网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。

　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：

　　**1> 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；**

　　**2> 基本数据单位为IP数据报；**

　　**3> 包含的主要协议：**

　　**IP协议（Internet Protocol，因特网互联协议）;**

　　**ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;**

　　**ARP协议（Address Resolution Protocol，地址解析协议）;**

　　**RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。**

　　**4> 重要的设备：路由器。**

### 传输层

第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。

　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。

　　网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。

　　有关网络层的重点：

　　**1> 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；**

　　**2> 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；**

　　**3> 重要设备：网关。**

### 会话层

　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步

### 表示层

　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。

### 应用层

　　为操作系统或网络应用程序提供访问网络服务的接口。

　　会话层、表示层和应用层重点：

　　**1> 数据传输基本单位为报文；**

　　**2> 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。**

 

# 网络通信要素
1. 通信双方地址
   * IP
   * 端口
2. 一定的规则（网络通信协议）
   * OSI参考模型：模型过于理想化，分为七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
   * TCP/IP参考模型（TCP/IP协议），分为：应用层（HTTP、FTP、Telnet、DNS等协议）、传输层（TCP、UDP等协议）、网络层（IP、ICMP、ARP等协议）、物理+数据链路层（Link协议）

## ip地址-InetAddress类

* 唯一的标识Internet上的计算机（通信实体）
* 本地地址（hostAddress）：127.0.0.1，主机名（hostName）；localhost
* IPV4和IPV6
  * IPV4：4个字节组成，4个0-255
  * IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示
* 公网地址和私有地址：192.168.开头的对应的是私有地址
* 域名：如：www.baidu.com，域名先找本机hosts文件查找对应的ip地址，如果未找到会经过域名解析服务器DNS进行解析成IP地址，从而访问网络服务器

```java
public class InetAdressTest {
    public static void main(String[] args) {
        try {
            //经过ip地址
            InetAddress byAddress1 = InetAddress.getByName("192.168.1.1");
            System.out.println(byAddress1);
            //通过域名
            InetAddress byName = InetAddress.getByName("www.baidu.com");
            System.out.println(byName);
            //本地回路地址127.0.0.1  域名localhost
            InetAddress localhost = InetAddress.getByName("localhost");
            System.out.println(localhost);
            //直接获取本机地址、本机回路地址、本机域名
            System.out.println(InetAddress.getLocalHost());
            System.out.println(localhost.getHostAddress());
            System.out.println(localhost.getHostName());
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
//输出：/192.168.1.1
//		www.baidu.com/180.101.49.11
//		localhost/127.0.0.1
//		DESKTOP-JRHETO1/192.168.1.13
//		127.0.0.1
//		localhost
```

## 端口

* 端口号标识正在计算机上运行的进程（程序）

* 不同的进程有不同的端口号

* 端口号为一个１６位的整数

* 端口分类：

  * 公认端口：0-1023，被预先定义的服务通信端口占用（如HTTP占用80，FTP占用21，Telnet占用23）

  * 注册端口：1024-49151，分配给用户进程或应用程序（如Tomcat占用8080，MySQL占用3306，Oracle占用1521）
  * 动态/私有端口：59152-65535

**端口号和IP地址组合得到一个网络套接字：Socket**

## 网络协议

> 计算机网络中实现通信必须遵守的约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等指定标准



**通信协议分层思想**：在指定协议时，把复杂成分分解成一些简单的成分，再进行复合。常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层、隔层不能通信。各层互不影响

**传输层两个重要协议：**

1. 传输控制协议TCP：Transmission Control Protocol
2. 用户数据报协议UDP：User Datagram Protocol

## TCP/IP协议簇

TCP/IP是两个主要协议：传输层协议TCP和网络互联协议IP命名，实际上是一组协议，包括多个具有不同功能且互为关联的协议

1. 传输控制协议TCP：Transmission Control Protocol
2. IP（Internet Protocol）：网络层的主要协议，支持网络间互联的数据通信

TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构：

1. 物理链路层
2. IP层（网络层）
3. 传输层
4. 应用层

# TCP和UDP

## TCP

### TCP特点

* 使用TCP前，需要建立TCP连接，形成传输数据通道
* 采用**“三次握手”**方式，点对点通信，是可靠的通信

![三次握手](https://gitee.com/tianzhendong/img/raw/master//images/image-20210727222452305.png)

* TCP协议进行通信的两个应用进程：客户端、服务端
* 在连接中可进行大数据量的传输
* 传输完毕，需要释放已经建立的连接，效率低，**“四次挥手”**

![](https://gitee.com/tianzhendong/img/raw/master//images/image-20210727222400368.png)

客户端和服务端均可以发起挥手动作（一般是客户端），在socket编程中，任何一方执行close（）即可产生挥手操作

### TCP网络编程实例

```java
package com.tian.javastudy.InetAddressDemo;
/*
* TCP网络编程
* 客户端发送数据给服务端，服务端在控制台显示输出
* */
import org.junit.Test;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;

public class TCPTest1 {
    //服务端
    @Test
    public void server(){
        ServerSocket serverSocket = null;
        Socket accept = null;
        InputStream inputStream = null;
        ByteArrayOutputStream baos = null;
        try {
            //创建服务端的serversocket，指明自己的端口号
            serverSocket = new ServerSocket(8899);
            //调用accept（）方法，接受来自客户端的socket
            accept = serverSocket.accept();
            //获取一个输入流，并读取数据
            inputStream = accept.getInputStream();
            baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[5];
            int len;
            while ((len = inputStream.read(buffer)) != -1){
                baos.write(buffer,0,len);
            }
            System.out.println(baos.toString());
            //获取发送方的ip
            System.out.println("发送方为："+ accept.getInetAddress().getHostName());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            if(baos != null){
                try {
                    baos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(inputStream != null){
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(accept != null){
                try {
                    accept.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(serverSocket != null){
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    //客户端
    @Test
    public void client() {
        Socket socket = null;
        OutputStream outputStream = null;
        try {
            //创建socket对象，指明服务器端的ip和端口号
            InetAddress inet = InetAddress.getByName("127.0.0.111");
            socket = new Socket(inet, 8899);
            //获取一个输出流，并写出数据
            outputStream = socket.getOutputStream();
            outputStream.write("你好，我是客户端".getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            if(outputStream!=null){
                try {
                    outputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(socket!=null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
/*
你好，我是客户端
发送方为：127.0.0.1
*/
```

### 客户端-服务端

#### 客户端

* 自定义
* 浏览器

#### 服务端

* 自定义
* Tomcat服务器

## UDP

#### 特点

* 将数据、源、目的地封装成数据包，不需要建立连接
* 每个数据报的大小限制再64K内
* 发送不管对方是否准备好，接收方收到也不确认，是不可靠的
* 可以广播发送
* 发送数据结束时无需释放资源，开销小，速度快

#### UDP网络编程

* 类DatagramSocket和DataGramPacket实现了基于UDP协议网络程序
* UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不确定什么时候可以送到
* DataGramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
* UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接，如同发快递包裹一样

```java
package com.tian.javastudy.InetAddressDemo;

import org.junit.Test;

import java.io.IOException;
import java.net.*;

public class UDPTest1 {
    //发送端
    @Test
    public void sender() throws IOException {
        //socket,无需包括接收方信息
        DatagramSocket socket = new DatagramSocket();
        //定义发送的信息
        String s = "我是发送方";
        //发送的字节长度
        byte[] bytes = s.getBytes();
        int len = bytes.length;
        //目的ip，这里发送到本机
        InetAddress inet = InetAddress.getLocalHost();
        //DataGramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
        DatagramPacket packet = new DatagramPacket(bytes, 0, len, inet, 8899);
        //发送
        socket.send(packet);
        //关闭
        socket.close();
    }

    //接收方
    @Test
    public void receiver() throws IOException {
        //接收方端口
        DatagramSocket socket = new DatagramSocket(8899);
        //DatagramSocket
        byte[] bytes = new byte[100];
        DatagramPacket packet = new DatagramPacket(bytes,0,bytes.length);
        //接受
        socket.receive(packet);
        //保存数据，实际上已经存在了bytes数组中，但是不知道实际的长度
        String s = new String(packet.getData(),0,packet.getLength());
        //输出到控制台
        System.out.println(s);
    }
}
/*
我是发送方
*/
```

# URL网络编程

## 特点

* URL（Uniform Resource Locator）：统一资源定位符，表示Internet上某一资源的地址（种子）
* 通过URL我们可以访问Internet上的各种网络资源，比如最常见的www、ftp站点，浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源

## 基本结构

由五个部分组成：<传输协议>://<主机名>:<端口号>/<文件名>#片段名?参数列表

如：http://localhost:8080/examples/beauty.jpg

* 传输协议：http
* 主机名：localhost
* 端口号：8080
* 文件名：examples/beauty.jpg
* 片段名：即锚点，例如看小说，直接定位到章节
* 参数列表格式：参数名=参数值&参数名=参数值

## 方法

![image-20210728000101287](https://gitee.com/tianzhendong/img/raw/master//images/image-20210728000101287.png)











