[toc]

# 通讯数据格式转换（float/real-word-byte)

## 前言

在上位机和下位机进行通讯的时候，通常要进行数据转换为字节（8位）或者word（16位）进行传输

modubusTCP在传输时，通过**读写保持性寄存器**位进行数据传输，一个保持性寄存器占有**2个byte**，**16个bite**，传输的数据常为**float型（4个byte，32位）**，需要进行转换

浮点数的表示通常采用**IEEE 754浮点数标准**，可以参考文章[IEEE754标准的浮点数存储格式](https://www.cnblogs.com/MikeZhang/p/IEEE754FloatEncode20180117.html)

IEEE754转换：[在线转换网址](http://www.speedfly.cn/tools/hexconvert/)

## 转换

其中float-byte、byte-float代码转自CSDN文章：[float型数据与4字节之间的转换,作者tutu-hu](https://blog.csdn.net/weixin_42700740/article/details/103236885?share_token=7af34e32-1bce-4b09-9225-afa6e02006f6)

### float-byte（32位浮点数转4个8位）

**2进制，与运算，左移运算**

```c++
/*将浮点数f转化为4个字节数据存放在byte[4]中*/
unsigned char* Float_to_Byte(float f)
{
	float float_data = 0;
	unsigned long longdata = 0;
	longdata = *(unsigned long*)&f;           //注意，会丢失精度
	byte[0] = (longdata & 0xFF000000) >> 24;
	byte[1] = (longdata & 0x00FF0000) >> 16;
	byte[2] = (longdata & 0x0000FF00) >> 8;
	byte[3] = (longdata & 0x000000FF);
	return byte;
}
```

### float-word（32位浮点数转2个16位）

```c++
unsigned int* Float_to_word(float f)
{
    unsigned long longdata = 0;
    longdata = *(unsigned long*)&f;           //注意，会丢失精度
    word[0] = (longdata & 0xFFFF0000) >> 16;
    word[1] = (longdata & 0x0000FFFF);
    return word;
}
```

### byte-float（4个8位转1个32位浮点数）

```c++
/*将4个字节数据byte[4]转化为浮点数存放在*f中*/

float Byte_to_Float(unsigned char *p)
{
	float float_data=0;
	unsigned long longdata = 0;
	longdata = (*p<< 24) + (*(p+1) << 16) + (*(p + 2) << 8) + (*(p + 3) << 0);
	float_data = *(float*)&longdata;
	return float_data;
}
```



### word-float（2个16位合成1个32位浮点数）



```c++
float Byte_to_Float(unsigned char *p)
{
	float float_data=0;
	unsigned long longdata = 0;
	longdata = (*p<< 16) + (*(p+1) << 0);
	float_data = *(float*)&longdata;
	return float_data;
}
```

### byte-word（2个8位合成1个16位）

两个8位数如何转化为16位数？

```c++
int data = (a<<8) & b;
```

```c++
char a;//高位
char b;//低位
....
int data = (a<<8)&0xFF00;
data &= b;
```

