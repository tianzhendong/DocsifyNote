[toc]

# 通讯数据格式

## 前言

在上位机和下位机进行通讯的时候，通常要进行数据转换为字节或者word进行传输

modubusTCP在传输时，通过读写保持性寄存器位进行数据传输，一个保持性寄存器占有2个byte，16个bite，传输的数据常为float型（4个byte，32位），需要进行转换

## 转换

### float-byte

**2进制，与运算，左移运算**

```c++
/*将浮点数f转化为4个字节数据存放在byte[4]中*/
unsigned char* Float_to_Byte(float f)
{
	float float_data = 0;
	unsigned long longdata = 0;
	longdata = *(unsigned long*)&f;           //注意，会丢失精度
	byte[0] = (longdata & 0xFF000000) >> 24;
	byte[1] = (longdata & 0x00FF0000) >> 16;
	byte[2] = (longdata & 0x0000FF00) >> 8;
	byte[3] = (longdata & 0x000000FF);
	return byte;
}
```

### float-word

```c++
unsigned int* Float_to_word(float f)
{
    unsigned long longdata = 0;
    longdata = *(unsigned long*)&f;           //注意，会丢失精度
    word[0] = (longdata & 0xFFFF0000) >> 16;
    word[1] = (longdata & 0x0000FFFF);
    return word;
}
```

### byte-float

```c++
/*将4个字节数据byte[4]转化为浮点数存放在*f中*/

float Byte_to_Float(unsigned char *p)
{
	float float_data=0;
	unsigned long longdata = 0;
	longdata = (*p<< 24) + (*(p+1) << 16) + (*(p + 2) << 8) + (*(p + 3) << 0);
	float_data = *(float*)&longdata;
	return float_data;
}
```



### word-float



```c++
float Byte_to_Float(unsigned char *p)
{
	float float_data=0;
	unsigned long longdata = 0;
	longdata = (*p<< 16) + (*(p+1) << 0);
	float_data = *(float*)&longdata;
	return float_data;
}
```

### byte-word

两个8位数如何转化为16位数？

```c++
int data = (a<<8) & b;
```

```c++
char a;//高位
char b;//低位
....
int data = (a<<8)&0xFF00;
data &= b;
```

