# 卡尔曼滤波

[toc]

## 什么是卡尔曼滤波

### 用途

对状态进行估计。

### 简单理解

如何通俗并尽可能详细地解释卡尔曼滤波？ - Kent Zeng的回答 - 知乎 https://www.zhihu.com/question/23971601/answer/26254459

假设你有两个传感器，测的是同一个信号。可是它们每次的读数都不太一样，怎么办？

**取平均。**

再假设你知道其中贵的那个传感器应该准一些，便宜的那个应该差一些。那有比取平均更好的办法吗？

**加权平均。**

怎么加权？假设两个传感器的误差都符合正态分布，假设你知道这两个正态分布的方差，用这两个方差值，（此处省略若干数学公式），你可以得到一个“最优”的权重。

接下来，重点来了：假设你只有一个传感器，但是你还有一个数学模型。模型可以帮你算出一个值，但也不是那么准。怎么办？

**把模型算出来的值，和传感器测出的值，（就像两个传感器那样），取加权平均。**

OK，最后一点说明：你的模型其实只是一个步长的，也就是说，知道x(k)，我可以求x(k+1)。问题是x(k)是多少呢？答案：x(k)就是你上一步卡尔曼滤波得到的、所谓加权平均之后的那个、对x在k时刻的最佳估计值。

于是**迭代**也有了。

这就是卡尔曼滤波。

### 结合实例理解

如何通俗并尽可能详细地解释卡尔曼滤波？ - 司南牧(李韬)的回答 - 知乎 https://www.zhihu.com/question/23971601/answer/770830003

以机器人估计自己离障碍物距离$X(k)$为例

已知数据：

- **观测值**：**传感器测量**的机器人距离障碍物的距离7m
- 上一时刻机器人距离障碍物的距离$X(k-1)=10m$
- 机器人的速度$V=4m/s$

根据2和3可以估算出机器人距离障碍物的距离，为**估计值**：$x=10-4*1=6m$

现在一个观测值一个估计值，应该相信谁？（速度不准确或者传感器坏了）

取加权平均，权重根据哪个数据更可信（如测量值准确度为90%，速度估计准确度为80%）

$$result = (1-{{0.9}\over{0.8+0.9}})*6+{0.9\over0.8+0.9}*7 = 6.52m$$

${0.9\over0.8+0.9}$即为**卡尔曼增益**



## 卡尔曼滤波推导

https://zhuanlan.zhihu.com/p/48876718





## 卡尔曼滤波公式

### 模型

假设一离散**线性动态系统**的模型如下所示：

![image-20220324160651305](https://gitee.com/tianzhendong/img/raw/master/images/202203241606383.png)

### 分析

对于状态估计算法而言，我们可以获取状态量的三个值：**状态预测值**、**最优估计值**、**真实值**，卡尔曼滤波的原理就是利用卡尔曼增益来修正状态预测值，使其逼近真实值。

### 公式



![image-20220324161513463](https://gitee.com/tianzhendong/img/raw/master/images/202203241615606.png)

![image-20220324161537180](https://gitee.com/tianzhendong/img/raw/master/images/202203241615385.png)

### 参数说明

- **P：预估误差协方差**，值到底可信度是多少，它的初值你可以直接设为1或者随你喜欢的一个值(反正不能设为0,在卡尔曼滤波状态更新中这个值会自动调整)，一定程度上代表了初值的可信度，所以初值很烂还给了很小的p的话结果惨不忍睹
- **Q：预测噪声协方差矩阵**，经验值，越小表示越信任预测值,为0的话表示完全相信预测值,越大表示越相信测量值
- **R：测量噪声协方差**，传感器的靠谱程度,换句话说,这个值你可以自己看着办

不知道怎么设置的话。R为大于0常数都可以 比如1 。 P初始值设为足够大的对角矩阵。Q大小影响收敛速度。可以试验几个数值。

![image-20220324170550505](https://gitee.com/tianzhendong/img/raw/master/images/202203241705576.png)



![卡尔曼滤波算法--核心公式推导导论](https://gitee.com/tianzhendong/img/raw/master/images/202203241613959.jpeg)

## 代码

### C

```h
/*
 * FileName : kalman_filter.h
 * Author   : xiahouzuoxin @163.com
 * Version  : v1.0
 * Date     : 2014/9/24 20:37:01
 * Brief    : 
 * 
 * Copyright (C) MICL,USTB
 */
#ifndef  _KALMAN_FILTER_H
#define  _KALMAN_FILTER_H

/* 
 * NOTES: n Dimension means the state is n dimension, 
 * measurement always 1 dimension 
 */

/* 1 Dimension */
typedef struct {
    float x;  /* state */
    float A;  /* x(n)=A*x(n-1)+u(n),u(n)~N(0,q) */
    float H;  /* z(n)=H*x(n)+w(n),w(n)~N(0,r)   */
    float q;  /* process(predict) noise convariance */
    float r;  /* measure noise convariance */
    float p;  /* estimated error convariance */
    float gain;
} kalman1_state;

/* 2 Dimension */
typedef struct {
    float x[2];     /* state: [0]-angle [1]-diffrence of angle, 2x1 */
    float A[2][2];  /* X(n)=A*X(n-1)+U(n),U(n)~N(0,q), 2x2 */
    float H[2];     /* Z(n)=H*X(n)+W(n),W(n)~N(0,r), 1x2   */
    float q[2];     /* process(predict) noise convariance,2x1 [q0,0; 0,q1] */
    float r;        /* measure noise convariance */
    float p[2][2];  /* estimated error convariance,2x2 [p0 p1; p2 p3] */
    float gain[2];  /* 2x1 */
} kalman2_state;                   

extern void kalman1_init(kalman1_state *state, float init_x, float init_p);
extern float kalman1_filter(kalman1_state *state, float z_measure);
extern void kalman2_init(kalman2_state *state, float *init_x, float (*init_p)[2]);
extern float kalman2_filter(kalman2_state *state, float z_measure);

#endif  /*_KALMAN_FILTER_H*/


```

```c
/*
 * FileName : kalman_filter.c
 * Author   : xiahouzuoxin @163.com
 * Version  : v1.0
 * Date     : 2014/9/24 20:36:51
 * Brief    : 
 * 
 * Copyright (C) MICL,USTB
 */
 
#include "kalman_filter.h"

/*
 * @brief   
 *   Init fields of structure @kalman1_state.
 *   I make some defaults in this init function:
 *     A = 1;
 *     H = 1; 
 *   and @q,@r are valued after prior tests.
 *
 *   NOTES: Please change A,H,q,r according to your application.
 *
 * @inputs  
 *   state - Klaman filter structure
 *   init_x - initial x state value   
 *   init_p - initial estimated error convariance
 * @outputs 
 * @retval  
 */
void kalman1_init(kalman1_state *state, float init_x, float init_p)
{
    state->x = init_x;
    state->p = init_p;
    state->A = 1;
    state->H = 1;
    state->q = 2e2;//10e-6;  /* predict noise convariance */
    state->r = 5e2;//10e-5;  /* measure error convariance */
}

/*
 * @brief   
 *   1 Dimension Kalman filter
 * @inputs  
 *   state - Klaman filter structure
 *   z_measure - Measure value
 * @outputs 
 * @retval  
 *   Estimated result
 */
float kalman1_filter(kalman1_state *state, float z_measure)
{
    /* Predict */
    state->x = state->A * state->x;
    state->p = state->A * state->A * state->p + state->q;  /* p(n|n-1)=A^2*p(n-1|n-1)+q */

    /* Measurement */
    state->gain = state->p * state->H / (state->p * state->H * state->H + state->r);
    state->x = state->x + state->gain * (z_measure - state->H * state->x);
    state->p = (1 - state->gain * state->H) * state->p;

    return state->x;
}

/*
 * @brief   
 *   Init fields of structure @kalman1_state.
 *   I make some defaults in this init function:
 *     A = {{1, 0.1}, {0, 1}};
 *     H = {1,0}; 
 *   and @q,@r are valued after prior tests. 
 *
 *   NOTES: Please change A,H,q,r according to your application.
 *
 * @inputs  
 * @outputs 
 * @retval  
 */
void kalman2_init(kalman2_state *state, float *init_x, float (*init_p)[2])
{
    state->x[0]    = init_x[0];
    state->x[1]    = init_x[1];
    state->p[0][0] = init_p[0][0];
    state->p[0][1] = init_p[0][1];
    state->p[1][0] = init_p[1][0];
    state->p[1][1] = init_p[1][1];
    //state->A       = {{1, 0.1}, {0, 1}};
    state->A[0][0] = 1;
    state->A[0][1] = 0.1;
    state->A[1][0] = 0;
    state->A[1][1] = 1;
    //state->H       = {1,0};
    state->H[0]    = 1;
    state->H[1]    = 0;
    //state->q       = {{10e-6,0}, {0,10e-6}};  /* measure noise convariance */
    state->q[0]    = 10e-7;
    state->q[1]    = 10e-7;
    state->r       = 10e-7;  /* estimated error convariance */
}

/*
 * @brief   
 *   2 Dimension kalman filter
 * @inputs  
 *   state - Klaman filter structure
 *   z_measure - Measure value
 * @outputs 
 *   state->x[0] - Updated state value, Such as angle,velocity
 *   state->x[1] - Updated state value, Such as diffrence angle, acceleration
 *   state->p    - Updated estimated error convatiance matrix
 * @retval  
 *   Return value is equals to state->x[0], so maybe angle or velocity.
 */
float kalman2_filter(kalman2_state *state, float z_measure)
{
    float temp0 = 0.0f;
    float temp1 = 0.0f;
    float temp = 0.0f;

    /* Step1: Predict */
    state->x[0] = state->A[0][0] * state->x[0] + state->A[0][1] * state->x[1];
    state->x[1] = state->A[1][0] * state->x[0] + state->A[1][1] * state->x[1];
    /* p(n|n-1)=A^2*p(n-1|n-1)+q */
    state->p[0][0] = state->A[0][0] * state->p[0][0] + state->A[0][1] * state->p[1][0] + state->q[0];
    state->p[0][1] = state->A[0][0] * state->p[0][1] + state->A[1][1] * state->p[1][1];
    state->p[1][0] = state->A[1][0] * state->p[0][0] + state->A[0][1] * state->p[1][0];
    state->p[1][1] = state->A[1][0] * state->p[0][1] + state->A[1][1] * state->p[1][1] + state->q[1];

    /* Step2: Measurement */
    /* gain = p * H^T * [r + H * p * H^T]^(-1), H^T means transpose. */
    temp0 = state->p[0][0] * state->H[0] + state->p[0][1] * state->H[1];
    temp1 = state->p[1][0] * state->H[0] + state->p[1][1] * state->H[1];
    temp  = state->r + state->H[0] * temp0 + state->H[1] * temp1;
    state->gain[0] = temp0 / temp;
    state->gain[1] = temp1 / temp;
    /* x(n|n) = x(n|n-1) + gain(n) * [z_measure - H(n)*x(n|n-1)]*/
    temp = state->H[0] * state->x[0] + state->H[1] * state->x[1];
    state->x[0] = state->x[0] + state->gain[0] * (z_measure - temp); 
    state->x[1] = state->x[1] + state->gain[1] * (z_measure - temp);

    /* Update @p: p(n|n) = [I - gain * H] * p(n|n-1) */
    state->p[0][0] = (1 - state->gain[0] * state->H[0]) * state->p[0][0];
    state->p[0][1] = (1 - state->gain[0] * state->H[1]) * state->p[0][1];
    state->p[1][0] = (1 - state->gain[1] * state->H[0]) * state->p[1][0];
    state->p[1][1] = (1 - state->gain[1] * state->H[1]) * state->p[1][1];

    return state->x[0];
}
```



### python

```python
import numpy as np


t = np.linspace(1,100,100) # 在1~100s内采样100次
a = 0.5 # 加速度值
position = (a * t**2)/2

position_noise = position+np.random.normal(0,120,size=(t.shape[0])) # 模拟生成GPS位置测量数据（带噪声）
import matplotlib.pyplot as plt
plt.plot(t,position,label='truth position')
plt.plot(t,position_noise,label='only use measured position')


#---------------卡尔曼滤波----------------
# 初始的估计导弹的位置就直接用GPS测量的位置
predicts = [position_noise[0]]
position_predict = predicts[0]

predict_var = 0
odo_var = 120**2 #这是我们自己设定的位置测量仪器的方差，越大则测量值占比越低
v_std = 50 # 测量仪器的方差（这个方差在现实生活中是需要我们进行传感器标定才能算出来的，可搜Allan方差标定）
for i in range(1,t.shape[0]):
  
    dv =  (position[i]-position[i-1]) + np.random.normal(0,50) # 模拟从IMU读取出的速度
    position_predict = position_predict + dv # 利用上个时刻的位置和速度预测当前位置
    predict_var += v_std**2 # 更新预测数据的方差
    # 下面是Kalman滤波
    position_predict = position_predict*odo_var/(predict_var + odo_var)+position_noise[i]*predict_var/(predict_var + odo_var)
    predict_var = (predict_var * odo_var)/(predict_var + odo_var)
    predicts.append(position_predict)

    
plt.plot(t,predicts,label='kalman filtered position')

plt.legend()
plt.show()
```

### plc

```c
//Initialize

// update prior
#xk_p := #xk_1 + #dt*#dxk_1;
#dxk_p := #dxk_1;

// update Pk_p
// 
#Pk_p._11 := #Pk_1._11 + #dt * (#Pk_1._21 + #Pk_1._12) + #dt * #dt * #Pk_1._22 + #Q._11;
#Pk_p._21 := #Pk_1._21 + #dt * #Pk_1._22 + #Q._21;
#Pk_p._12 := #Pk_1._12 + #dt * #Pk_1._22 + #Q._12;
#Pk_p._22 := #Pk_1._22 + #Q._22;

//Kk
#Kk._11 := #Pk_p._11 / (#Pk_p._11 + #R);
#Kk._21 := #Pk_p._21 / (#Pk_p._11 + #R);

// update states
//
#xk := #xk_p + #Kk._11 * (REAL_TO_LREAL(#zk) - #xk_p);
#dxk := #dxk_p + #Kk._21* (REAL_TO_LREAL(#zk) - #xk_p);
//
#Pk._11 := #Pk_p._11 * (1 - #Kk._11);
#Pk._21 := #Pk_p._21 - #Pk_p._11 * #Kk._21;
#Pk._12 := #Pk_p._12 * (1 - #Kk._11);
#Pk._22 := #Pk_p._22 - #Pk_p._12 * #Kk._21;
```

调用

```c
// -- Rotation Axis
"KalmanFilter"(zk:="State".MEA_k.rot,
               xk_1:="State".States_k_1.rot,
               dxk_1:="State".States_k_1.d_rot,
               Pk_1:="State".Pk_1_rot,
               dt:="Parameters".KF_dt,
               Q:="Parameters".KFParas_rot.Q,
               R:="Parameters".KFParas_rot.R,
               Pk=>"State".Pk_rot,
               xk=>"State".States_k.rot,
               dxk=>"State".States_k.d_rot);
```

初始化

```c
// Safefy
// 
"State".KF_stableFlag := FALSE;
// Parameters initialization
// 
#dt2 := "Parameters".KF_dt * "Parameters".KF_dt;
#dt3 := "Parameters".KF_dt * "Parameters".KF_dt * "Parameters".KF_dt;
#dt4 := "Parameters".KF_dt * "Parameters".KF_dt * "Parameters".KF_dt * "Parameters".KF_dt;

"Parameters".KFParas_rot.Q._11 := #dt4 / 4 * "Parameters".KFParas_rot.sig_a2;
"Parameters".KFParas_rot.Q._21 := #dt3 / 2 * "Parameters".KFParas_rot.sig_a2;
"Parameters".KFParas_rot.Q._12 := #dt3 / 2 * "Parameters".KFParas_rot.sig_a2;
"Parameters".KFParas_rot.Q._22 := #dt2 * "Parameters".KFParas_rot.sig_a2;

"Parameters".KFParas_tran.Q._11 := #dt4 / 4 * "Parameters".KFParas_tran.sig_a2;
"Parameters".KFParas_tran.Q._21 := #dt3 / 2 * "Parameters".KFParas_tran.sig_a2;
"Parameters".KFParas_tran.Q._12 := #dt3 / 2 * "Parameters".KFParas_tran.sig_a2;
"Parameters".KFParas_tran.Q._22 := #dt2 * "Parameters".KFParas_tran.sig_a2;

"Parameters".KFParas_lift.Q._11 := #dt4 / 4 * "Parameters".KFParas_lift.sig_a2;
"Parameters".KFParas_lift.Q._21 := #dt3 / 2 * "Parameters".KFParas_lift.sig_a2;
"Parameters".KFParas_lift.Q._12 := #dt3 / 2 * "Parameters".KFParas_lift.sig_a2;
"Parameters".KFParas_lift.Q._22 := #dt2 * "Parameters".KFParas_lift.sig_a2;


// Measurements and States initialization
"State".MEA_k.rot := INT_TO_REAL("sens_rot_ai_pn");
"State".MEA_k.tran := DWORD_TO_REAL("sens_tran_ai_dp");
"State".MEA_k.lift := DWORD_TO_REAL("sens_lift_ai_dp");

"State".MEA_k_1 := "State".MEA_k;

"State".States_k.rot := "State"."MEA_k".rot;
"State".States_k.tran := "State"."MEA_k".tran;
"State".States_k.lift := "State"."MEA_k".lift;
"State".States_k.d_rot := 0;
"State".States_k.d_tran := 0;
"State".States_k.d_lift := 0;
"State".States_k_1 := "State".States_k;

// Covariance initialization
"State".Pk_rot._11 := 0;
"State".Pk_rot._12 := 0;
"State".Pk_rot._21 := 0;
"State".Pk_rot._22 := 0;
"State".Pk_tran := "State".Pk_rot;
"State".Pk_lift := "State".Pk_rot;
"State".Pk_1_rot := "State".Pk_rot;
"State".Pk_1_tran := "State".Pk_rot;
"State".Pk_1_lift := "State".Pk_rot;

// Position commands initialization
"State".CMD.pos_rot := 0.0;
"State".CMD.pos_tran := 0.0;
"State".CMD.pos_lift := 0.0;

```

