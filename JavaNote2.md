# 面向对象

>**类和对象、内存底层、面向对象三个特征、特殊类**

> 互联网上的所有数据，本质上都是“表格”

**面向过程时一种“设计者”思维；   面向对象是一种“设计者”思维。**

## 对象和类

### 类的声明

```
public class SxtSut{
    //属性（成员变量）
    int id;
    String sname;
    int age;
    //方法
    void study(){
        ...
    }
    //构造方法，可有可无
    SxtStu(){
    }
}
```
### 成员变量的默认值：

数据类型|默认值
--|-|
整型|0
浮点型|0.0
字符型|'\u0000"
布尔型|false
所有引用类型|null

### 构造方法

构造器也叫构造方法，用于对象的初始化，再对象创建的时候会自动调用；

* 构造器的调用是通过new调用的
* 构造器虽然有返回值，但是不能定义返回值类型（返回值的类型是本类），不能使用return
* 如果没有定义构造器，编译器会自动定义一个无参的构造函数，如果自己定义了，那么系统不会自定义
* 构造器的方法名称必须和类完全相同

## java虚拟机内存模型

### 从属于线程的内存分析

1. 程序计数器，每个线程都有自己的程序计数器，是一块比较小的内存空间，存储当前线程正在执行的java方法的JVM指令地址，即字节码的行号
2. java虚拟机栈，线程的私有区域，每个线程再创建的时候都会创建一个虚拟机栈，线程退出时，会被回收。方法调用时进行压栈操作，方法调用结束后进行出栈操作。该区域存储着局部变量表
3. 本地方法栈：与虚拟机栈类似，调用本地方法时使用的栈，每个线程都有一个本地方法栈。

#### 栈

1. 描述的是方法执行的内存模型，每个方法被调用时都被创建一个栈帧，存储局部变量、操作数、方法出口等；
2. jvm会为每个线程创建一个栈
3. 属于线程私有，不能共享
4. 存储特性：先进后出，后进先出

### 堆heap

几乎所有创建的java对象都会被直接分配到堆上。堆被所有的线程共享，再堆上的区域，会被垃圾回收器进一步划分为新生代、老年代。java虚拟机启动时，可以使用Xmx之类的参数指定堆区域的大小。

1. 存储数组（数组也是对象）和对象
2. jvm只有一个堆，被所有线程共享
3. 堆是一个不连续的空间，分配灵活，速度慢！

### 方法区

被所有线程共享，时一种java虚拟机的规范，存储被虚拟机加载的元数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据

由于方法去存储的数据和队中存储的数据一致，实质上也是堆。java不同版本实现方式不同

1. jvm只有一个方法区，被所有线程共享
2. 实际也是堆，不连续，只是用来存储类、常量等信息
3. 用来存放线程中永远是不变或者唯一的内容（类信息、静态常量、字符串常量）。

### 运行时常量池（方法区中）

存储final常量等

### 直接内存

直接内存并不属于java规范规定的属于java虚拟机运行时数据区的一部分。

## 垃圾回收机制Garbage Collection

**java的内存管理很大程度上指的就是：堆中对象的管理，其中包括对象空间的分配和释放。**


**对象空间的分配：new；对象空间的释放：赋值null即可，垃圾回收器将负责回收所有“不可达”对象（没有引用）的内存空间**

**垃圾回收相关算法**

1. 引用计数法：堆中每个对象都引用一个计数器。有点：算法简单；缺点：循环引用的无用对象无法识别
2. 引用可达法（根搜索算法）：程序把所有的引用关系看作一张图

## 通用的分代垃圾回收机制

不同的对象的生命周期是不一样的，采用不同的回收算法，提高回收效率。

分为年轻代、年老代、持久代，将不同状态的对象放到堆中不同的区域，JVM将堆内存划分为Eden、Survivor、Tenured/Old空间。

1. Eden区：存储了从未经过垃圾回收的新对象
2. Survivor区，存放经过垃圾回收后，仍然有用的对象，survivor1和2循环存放，小于15次垃圾回收次数
3. Tenured区，年老代区域存放超过15次垃圾回收的对象

1. Minor GC：用于清理年轻代区域，Eden区满了就会触发一次，清理无用对象，将有用对象复制到survivor1和2区
2. Major GC：用于清理年老代区域
3. Full GC：用于清理年轻代、年老代区域，成本较高，会对系统性能产生影响

**程序员无权调用垃圾回收器**

## 容易造成内存泄漏的情况

1. 创建大量无用对象，比如再需要大量拼接字符串时，使用了String而不是StringBuilder
2. 静态集合类的使用，如：HashMap、Vector、List等使用最容易造成内存泄漏，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放
3. 各种连接对象（IO流对象、数据库连接对象、网络连接对象）未关闭，这些对象属于物理连接，和硬盘或者网络连接，不适用的时候要关闭
4. 监听器的使用，释放对象时，未删除相应的监听器

System.gc()的作用：程序员建议启用垃圾回收进程



