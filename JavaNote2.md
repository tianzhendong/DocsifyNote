---
title: JavaNote2
tags: code
notebook: JAVA
---


# 面向对象

>**类和对象、内存底层、面向对象三个特征、特殊类**

> 互联网上的所有数据，本质上都是“表格”

**面向过程时一种“设计者”思维；   面向对象是一种“设计者”思维。**

## 对象和类

### 类的声明

```
public class SxtSut{
    //属性（成员变量）
    int id;
    String sname;
    int age;
    //方法
    void study(){
        ...
    }
    //构造方法，可有可无
    SxtStu(){
    }
}
```
### 成员变量的默认值：

数据类型|默认值
--|-|
整型|0
浮点型|0.0
字符型|'\u0000"
布尔型|false
所有引用类型|null

### 构造方法

构造器也叫构造方法，用于对象的初始化，再对象创建的时候会自动调用；

* 构造器的调用是通过new调用的
* 构造器虽然有返回值，但是不能定义返回值类型（返回值的类型是本类），不能使用return
* 如果没有定义构造器，编译器会自动定义一个无参的构造函数，如果自己定义了，那么系统不会自定义
* 构造器的方法名称必须和类完全相同

## java虚拟机内存模型

### 从属于线程的内存分析

1. 程序计数器，每个线程都有自己的程序计数器，是一块比较小的内存空间，存储当前线程正在执行的java方法的JVM指令地址，即字节码的行号
2. java虚拟机栈，线程的私有区域，每个线程再创建的时候都会创建一个虚拟机栈，线程退出时，会被回收。方法调用时进行压栈操作，方法调用结束后进行出栈操作。该区域存储着局部变量表
3. 本地方法栈：与虚拟机栈类似，调用本地方法时使用的栈，每个线程都有一个本地方法栈。

#### 栈

1. 描述的是方法执行的内存模型，每个方法被调用时都被创建一个栈帧，存储局部变量、操作数、方法出口等；
2. jvm会为每个线程创建一个栈
3. 属于线程私有，不能共享
4. 存储特性：先进后出，后进先出

### 堆heap

几乎所有创建的java对象都会被直接分配到堆上。堆被所有的线程共享，再堆上的区域，会被垃圾回收器进一步划分为新生代、老年代。java虚拟机启动时，可以使用Xmx之类的参数指定堆区域的大小。

1. 存储数组（数组也是对象）和对象
2. jvm只有一个堆，被所有线程共享
3. 堆是一个不连续的空间，分配灵活，速度慢！

### 方法区

被所有线程共享，时一种java虚拟机的规范，存储被虚拟机加载的元数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据

由于方法去存储的数据和队中存储的数据一致，实质上也是堆。java不同版本实现方式不同

1. jvm只有一个方法区，被所有线程共享
2. 实际也是堆，不连续，只是用来存储类、常量等信息
3. 用来存放线程中永远是不变或者唯一的内容（类信息、静态常量、字符串常量）。

### 运行时常量池（方法区中）

存储final常量等

### 直接内存

直接内存并不属于java规范规定的属于java虚拟机运行时数据区的一部分。

## 垃圾回收机制Garbage Collection

**java的内存管理很大程度上指的就是：堆中对象的管理，其中包括对象空间的分配和释放。**


**对象空间的分配：new；对象空间的释放：赋值null即可，垃圾回收器将负责回收所有“不可达”对象（没有引用）的内存空间**

**垃圾回收相关算法**

1. 引用计数法：堆中每个对象都引用一个计数器。有点：算法简单；缺点：循环引用的无用对象无法识别
2. 引用可达法（根搜索算法）：程序把所有的引用关系看作一张图

## 通用的分代垃圾回收机制

不同的对象的生命周期是不一样的，采用不同的回收算法，提高回收效率。

分为年轻代、年老代、持久代，将不同状态的对象放到堆中不同的区域，JVM将堆内存划分为Eden、Survivor、Tenured/Old空间。

1. Eden区：存储了从未经过垃圾回收的新对象
2. Survivor区，存放经过垃圾回收后，仍然有用的对象，survivor1和2循环存放，小于15次垃圾回收次数
3. Tenured区，年老代区域存放超过15次垃圾回收的对象

1. Minor GC：用于清理年轻代区域，Eden区满了就会触发一次，清理无用对象，将有用对象复制到survivor1和2区
2. Major GC：用于清理年老代区域
3. Full GC：用于清理年轻代、年老代区域，成本较高，会对系统性能产生影响

**程序员无权调用垃圾回收器**

## 容易造成内存泄漏的情况

1. 创建大量无用对象，比如再需要大量拼接字符串时，使用了String而不是StringBuilder
2. 静态集合类的使用，如：HashMap、Vector、List等使用最容易造成内存泄漏，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放
3. 各种连接对象（IO流对象、数据库连接对象、网络连接对象）未关闭，这些对象属于物理连接，和硬盘或者网络连接，不适用的时候要关闭
4. 监听器的使用，释放对象时，未删除相应的监听器

System.gc()的作用：程序员建议启用垃圾回收进程

##  包机制（package、import）

###  package

通过package实现对类的管理，包对于类，相当于文件夹对于文件的作用：
1. 通常是类的第一句非注释性语句；
2. 包名：域名倒着写即可，再加上模块名，便于内部管理类
```
com.sun.test;
com.oracle.test;
cn.sxt.gao.test;
```

导入：

```
import com.sun.test.* //导入该包下的所有类;
```


导入一个包内所有的类，会降低编译速度，但不会降低运行速度

## 继承extends

java中只有单继承，没有C++中的多继承，一个子类只有一个父类；

如果定义了一个类，没有调用extends，那么他的父类是java.lang.object

### instanceof运算符

二元运算符，左边是对象，右边是类，如果左边是右边类火子类的对象，则返回true，否则false

### 重写overwrite

1. 方法名、形参列表必须相同；
2. 返回值类型和声明异常类型，子类小于等于父类
3. 访问权限，子类大于等于父类。

## final关键字

1. 修饰变量，该变量不可改变；
2. 修饰方法，该方法不可以被子类重写，但是可以被重载！（重写：参数列表相同，重载：参数列表不同）；
3. 修饰类：修饰的类不能被重载；

## 继承和组合

组合：将父类对象作为子类的属性


## Object类

所有java类的父类；

### toString方法

```
public String toString(){
    return getClass().getName()+"@"+Integer.toHexString(hashCode());
}
// 默认返回“类名+@+16进制的hashcode”，再打印输出或者用字符串连接对象时，会自动调用该方法
```

###  "=="和equals方法

```
public boolen equals(Object obj){
    return(this == obj)
}
```
==的作用：

1. 基本类型：值是否相等；
2. 引用类型：内存地址是否相等；


equals：默认情况下比较内存地址是否相等，一般进行重写。

### super方法

子类中使用super方法，调用父类中的方法或属性。

子类中所有构造方法的第一句总会构造父类的构造器，你不加，编译器会自动加super（）进行调用父类的无参构造器。

## 封装

程序设计追求高内聚、低耦合，高内聚就是类的内部数据操作细节自己完成，不允许内部干涉；低耦合就是仅暴漏少量方法给外部使用，尽量方便外部调用；

封装的有点：

1. 提高代码的安全性
2. 提高代码的复用性
3. 高内聚：封装细节，便于修改内部代码，提高可维护性；
4. 低耦合：简化外部调用，便于调用者使用，方便扩展和写作。

### 封装的实现——访问控制符


修饰符|同一个类|同一个包|子类|所有类
-|-|-|-|-
private|yes|-|-|-
default|yes|yes|-|-
protected|yes|yes|yes|-
public|yes|yes|yes|yes

### 封装的简单规则：

1. 一般使用private访问权限；
2. 提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的（注意：boolean变量的get方法是is开头）
3. 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public调用



