---
title: 网络编程
tags: Code
notebook: JAVA
---

[toc]
# 网络基础
## 网络编程的目的
直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯
## 网络编程中两个主要问题
* 如何准确地定位网络上一台或多台主机，定位主机上的特定应用
* 找到住后如何可靠高效地进行数据传输

# 网络通信要素
1. 通信双方地址
   * IP
   * 端口
2. 一定的规则（网络通信协议）
   * OSI参考模型：模型过于理想化，分为七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
   * TCP/IP参考模型（TCP/IP协议），分为：应用层（HTTP、FTP、Telnet、DNS等协议）、传输层（TCP、UDP等协议）、网络层（IP、ICMP、ARP等协议）、物理+数据链路层（Link协议）

## ip地址-InetAddress类

* 唯一的标识Internet上的计算机（通信实体）
* 本地地址（hostAddress）：127.0.0.1，主机名（hostName）；localhost
* IPV4和IPV6
  * IPV4：4个字节组成，4个0-255
  * IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示
* 公网地址和私有地址：192.168.开头的对应的是私有地址
* 域名：如：www.baidu.com，域名先找本机hosts文件查找对应的ip地址，如果未找到会经过域名解析服务器DNS进行解析成IP地址，从而访问网络服务器

```java
public class InetAdressTest {
    public static void main(String[] args) {
        try {
            //经过ip地址
            InetAddress byAddress1 = InetAddress.getByName("192.168.1.1");
            System.out.println(byAddress1);
            //通过域名
            InetAddress byName = InetAddress.getByName("www.baidu.com");
            System.out.println(byName);
            //本地回路地址127.0.0.1  域名localhost
            InetAddress localhost = InetAddress.getByName("localhost");
            System.out.println(localhost);
            //直接获取本机地址、本机回路地址、本机域名
            System.out.println(InetAddress.getLocalHost());
            System.out.println(localhost.getHostAddress());
            System.out.println(localhost.getHostName());
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
//输出：/192.168.1.1
//		www.baidu.com/180.101.49.11
//		localhost/127.0.0.1
//		DESKTOP-JRHETO1/192.168.1.13
//		127.0.0.1
//		localhost
```

## 端口

* 端口号标识正在计算机上运行的进程（程序）

* 不同的进程有不同的端口号

* 端口号为一个１６位的整数

* 端口分类：

  * 公认端口：0-1023，被预先定义的服务通信端口占用（如HTTP占用80，FTP占用21，Telnet占用23）

  * 注册端口：1024-49151，分配给用户进程或应用程序（如Tomcat占用8080，MySQL占用3306，Oracle占用1521）
  * 动态/私有端口：59152-65535

**端口号和IP地址组合得到一个网络套接字：Socket**

## 网络协议

> 计算机网络中实现通信必须遵守的约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等指定标准



**通信协议分层思想**：在指定协议时，把复杂成分分解成一些简单的成分，再进行复合。常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层、隔层不能通信。各层互不影响

### **传输层两个重要协议：**

1. 传输控制协议TCP：Transmission Control Protocol
2. 用户数据报协议UDP：User Datagram Protocol

## TCP/IP协议簇

TCP/IP是两个主要协议：传输层协议TCP和网络互联协议IP命名，实际上是一组协议，包括多个具有不同功能且互为关联的协议

1. 传输控制协议TCP：Transmission Control Protocol
2. IP（Internet Protocol）：网络层的主要协议，支持网络间互联的数据通信

TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构：

1. 物理链路层
2. IP层（网络层）
3. 传输层
4. 应用层

# TCP和UDP

## TCP

### TCP特点

* 使用TCP前，需要建立TCP连接，形成传输数据通道
* 采用**“三次握手”**方式，点对点通信，是可靠的通信

![三次握手](https://gitee.com/tianzhendong/img/raw/master//images/image-20210727222452305.png)

* TCP协议进行通信的两个应用进程：客户端、服务端
* 在连接中可进行大数据量的传输
* 传输完毕，需要释放已经建立的连接，效率低，**“四次挥手”**

![](https://gitee.com/tianzhendong/img/raw/master//images/image-20210727222400368.png)

客户端和服务端均可以发起挥手动作（一般是客户端），在socket编程中，任何一方执行close（）即可产生挥手操作

### TCP网络编程实例

```java
package com.tian.javastudy.InetAddressDemo;
/*
* TCP网络编程
* 客户端发送数据给服务端，服务端在控制台显示输出
* */
import org.junit.Test;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;

public class TCPTest1 {
    //服务端
    @Test
    public void server(){
        ServerSocket serverSocket = null;
        Socket accept = null;
        InputStream inputStream = null;
        ByteArrayOutputStream baos = null;
        try {
            //创建服务端的serversocket，指明自己的端口号
            serverSocket = new ServerSocket(8899);
            //调用accept（）方法，接受来自客户端的socket
            accept = serverSocket.accept();
            //获取一个输入流，并读取数据
            inputStream = accept.getInputStream();
            baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[5];
            int len;
            while ((len = inputStream.read(buffer)) != -1){
                baos.write(buffer,0,len);
            }
            System.out.println(baos.toString());
            //获取发送方的ip
            System.out.println("发送方为："+ accept.getInetAddress().getHostName());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            if(baos != null){
                try {
                    baos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(inputStream != null){
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(accept != null){
                try {
                    accept.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(serverSocket != null){
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    //客户端
    @Test
    public void client() {
        Socket socket = null;
        OutputStream outputStream = null;
        try {
            //创建socket对象，指明服务器端的ip和端口号
            InetAddress inet = InetAddress.getByName("127.0.0.111");
            socket = new Socket(inet, 8899);
            //获取一个输出流，并写出数据
            outputStream = socket.getOutputStream();
            outputStream.write("你好，我是客户端".getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            if(outputStream!=null){
                try {
                    outputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(socket!=null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
/*
你好，我是客户端
发送方为：127.0.0.1
*/
```

### 客户端-服务端

#### 客户端

* 自定义
* 浏览器

#### 服务端

* 自定义
* Tomcat服务器

## UDP

#### 特点

* 将数据、源、目的地封装成数据包，不需要建立连接
* 每个数据报的大小限制再64K内
* 发送不管对方是否准备好，接收方收到也不确认，是不可靠的
* 可以广播发送
* 发送数据结束时无需释放资源，开销小，速度快

#### UDP网络编程

* 类DatagramSocket和DataGramPacket实现了基于UDP协议网络程序
* UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不确定什么时候可以送到
* DataGramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
* UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接，如同发快递包裹一样

```java
package com.tian.javastudy.InetAddressDemo;

import org.junit.Test;

import java.io.IOException;
import java.net.*;

public class UDPTest1 {
    //发送端
    @Test
    public void sender() throws IOException {
        //socket,无需包括接收方信息
        DatagramSocket socket = new DatagramSocket();
        //定义发送的信息
        String s = "我是发送方";
        //发送的字节长度
        byte[] bytes = s.getBytes();
        int len = bytes.length;
        //目的ip，这里发送到本机
        InetAddress inet = InetAddress.getLocalHost();
        //DataGramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
        DatagramPacket packet = new DatagramPacket(bytes, 0, len, inet, 8899);
        //发送
        socket.send(packet);
        //关闭
        socket.close();
    }

    //接收方
    @Test
    public void receiver() throws IOException {
        //接收方端口
        DatagramSocket socket = new DatagramSocket(8899);
        //DatagramSocket
        byte[] bytes = new byte[100];
        DatagramPacket packet = new DatagramPacket(bytes,0,bytes.length);
        //接受
        socket.receive(packet);
        //保存数据，实际上已经存在了bytes数组中，但是不知道实际的长度
        String s = new String(packet.getData(),0,packet.getLength());
        //输出到控制台
        System.out.println(s);
    }
}
/*
我是发送方
*/
```

# URL网络编程

## 特点

* URL（Uniform Resource Locator）：统一资源定位符，表示Internet上某一资源的地址（种子）
* 通过URL我们可以访问Internet上的各种网络资源，比如最常见的www、ftp站点，浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源

## 基本结构

由五个部分组成：<传输协议>://<主机名>:<端口号>/<文件名>#片段名?参数列表

如：http://localhost:8080/examples/beauty.jpg

* 传输协议：http
* 主机名：localhost
* 端口号：8080
* 文件名：examples/beauty.jpg
* 片段名：即锚点，例如看小说，直接定位到章节
* 参数列表格式：参数名=参数值&参数名=参数值

## 方法

![image-20210728000101287](https://gitee.com/tianzhendong/img/raw/master//images/image-20210728000101287.png)











