---
title: 容器
tags: JAVA
notebook: JAVA
---

# 泛型

JDK1.5（即5.0）后增加，帮助我们建立类型安全的集合

**本质是数据类型的参数化**：
1. 把类型当作是参数一样进行传递；
2. <数据类型>只能是引用类型

好处：
1. 代码可读性更好，不用强制转换
2. 程序更加安全，只要编译时间没有警告，运行时期就不会出现ClassCastException异常；

## 类型擦除

编码时采用泛型写的参数类型，编译器会在编译时去掉，即“类型擦除”，类型参数再编译后会被替换成Object，运行时虚拟机并不知道泛型。

## 定义泛型

可以使用任何字符表示标识符，一般用下面的：
|泛型标记|对应单词|说明|
|-|-|-|
|E|Element|在容器中使用，表示容器中的元素|
|T|Type|表示普通的java类|
|K|Key|表示键，如map中的键key|
|V|Value|表示值|
|N|Number|表示数值类型|
|？||表示不确定的java类型|

```java
//定义泛型类
public class Generic<T>{
    private T flag;
    public void setFlag(T flag){
        this.flag = flag;
    }
    public T getFlag(){
        return this.flag;
    }
}
```

```java
//泛型方法
public <泛型表示符号> void getName(泛型表示符号 name){

}
public <泛型表示符号> 泛型表示符号 getName(泛型表示符号 name){
}
```
```java
//静态方法定义，静态方法中不能使用类定义的泛型
public static<泛型表示符号> void getName(泛型表示符号 name){

}
public static<泛型表示符号> 泛型表示符号 getName(泛型表示符号 name){
}
```

```java
//通配符？，表示类型不确定的
public void showFlag(Generic<?> generic){

}

//通配符上限限定，如下，表示只能是number或者其子类
public void showFlag(Generic<? extend Number> generic){

}
//通配符下限限定，如下，表示只能是Integer或者其父类
public void showFlag(Generic<? super Integer> generic){

}
```

## 泛型总结

泛型主要用于编译阶段，编译生成的class文件不包含泛型中的类型信息，类型参数再编译后会被替换成Object

1. 基本类型不能用于泛型，但是可以用其对应的包装类

如
`Test<int> t;错误，可以用Test<Integer>t;`

2. 不能通过类型参数创建对象

T elm = new T();错误


# 容器

用来容纳和管理数据。

## 单例集合

将数据一个一个的进行存储；Collection接口，以单个数据未单位进行存储；

包括：
1. List接口：存储有序，可重复，“动态”数组，实现：ArrayList类、LinkedList类、Vector类
2. Set接口，存储无序，不可重复，数学中的“集合”

## 双例集合
基于key与value的结构存储数据，Map接口，数学中的函数y=f（x）


## 单例集合
## Collection
Collection接口时单例集合的根接口，包括两个子接口List、Set接口

抽象方法：
|方法|说明|
|-|-|
|boolean add(Object e)|增加元素|
|boolean remove(Object e)|删除|
|Boolean contains（Object e）|是否包含|
|int size（）|元素数量|
|Boolean isEmpty（）|是否为空|
|void clear（）|清空所有元素|
|Iterator iterator（）|获取迭代器，用于遍历所有元素|
|Boolean containsAll（Collection c）|判断是否包含C容器中的所有元素|
|Boolean addAll（Collection c）|将c中所有元素加到该容器|
|Boolean removeAll（c）|移出和c容器中都包含的元素|
|Boolean retainAll（c）|移除c中没有的元素|
|Object[] toArray()|转化成Object数组|

## list接口
有序、可重复，有序只是存储有顺序

|方法|说明|
|-|-|
|void add(int index,Object e|再指定位置插入元素，其余元素后移一位|
|Object set(int index, Object e|修改指定位置的元素，原来位置的元素的值返回|
|Object get（int index）|返回指定位置的元素|
|Object remove(int index)|删除元素，并返回删除的元素|
|int indexOf(Object o)|返回第一匹配元素的索引，若无，则返回-1|
|int lastIndexOf(Object o)|返回最后一个匹配到的元素索引，若无，则返回-1|

## ArrayList容器类
LIst接口的实现类，是List存储特征的具体实现，

底层使用数组实现的存储，**特点：查询效率高（使用数组实现），增删效率低（增删后其余元素的索引都要变），线程不安全。**

